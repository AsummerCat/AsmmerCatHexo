---
title: JVM笔记方法区与元空间
date: 2020-07-22 14:54:55
tags: [JVM笔记]
---

# JVM笔记方法区与元空间

## 堆丶栈丶方法区的交互关系
![堆丶栈丶方法区的交互关系](/img/2020-07-02/37.png)

<!--more-->
## 方法区概述
可以看做一块独立于Java堆的内存空间,  
可以动态扩容和收缩,  
存放的是关于类(class)的一些信息  
方法区的大小决定了系统可以保存多少个类,JVM保存了太多的类,也会内存溢出.  
JVM: 1.7之前叫做方法区<--->1.7及其之后叫做元空间  
![方法区的基本理解](/img/2020-07-02/38.png)

## 设置方法区的大小与OOM

### JVM参数:设置方法区大小
#### jdk1.7及之前
```
通过:
 -XX:PremSize=size 来设置永久代初始分配空间,默认20.75M
 -XX:MaxPermSize=size 来设定永久代最大可分配内存 
 32位系统默认是64M 
 64位系统默认是82M
```
#### jdk1.8之后
```
通过:
 -XX:MetaspaceSize=size 来设置初始化元空间大小
 -XX:MaxMetaspaceSize=size 来设置最大元空间大小
```
![JVM参数:设置方法区大小](/img/2020-07-02/39.png)

## 方法区的内部结构
```
主要存放:
1. class的类型信息
2. 运行时常量池,常量
3. 静态变量
4. 即时编译器编译后的代码缓存(JIT)
5. 域信息
6. 方法信息

注意点:
字符串常量池在Java内存区域的哪个位置？
在JDK6.0及之前版本，字符串常量池是放在Perm Gen区(也就是方法区)中；
在JDK7.0版本，字符串常量池被移到了堆中了。
至于为什么移到堆内，大概是由于方法区的内存空间太小了。

```
![方法区的内部结构](/img/2020-07-02/40.png)  
![方法区的内部结构1](/img/2020-07-02/41.png)
### 类型信息
![类型信息](/img/2020-07-02/42.png)

### 域信息 (属性信息)
![域信息](/img/2020-07-02/43.png)

### 方法信息
![方法信息](/img/2020-07-02/44.png)
还有异常表 也会存放在这里

### 运行时常量池
 ![运行时常量池](/img/2020-07-02/45.png)   
 ![常量池的内容](/img/2020-07-02/47.png)

#####  为什么需要常量池(class生成的)
![为什么需要常量池](/img/2020-07-02/46.png)

```
总结:
  常量池可以当做一张表,虚拟机指令根据这张常量表的找到  
要执行的类名,方法名,参数类型,字面量等类型  
```
```
注意:
  运行时常量池是方法区的一部分
  常量表是class文件的一部分(用于编译期生成各种字面量与符号引用)
  运行时常量池,在加载类和接口到虚拟机后,就会创建对应的运行时常量池
  
```
![为什么需要常量池](/img/2020-07-02/48.png)

##### 字符串常量池为什么要调整到堆内
![字符串常量池为什么要调整到堆内](/img/2020-07-02/49.png)

##### 静态变量
```
静态变量 
在1.7之前存放在永久代里
在1.8之后存放在堆空间里

ps:需要注意的是 无论哪个版本 :静态引用的对象都是放在堆里空间里的
比如: static byte[] a=new byte[1024*1024]
  左边引用是根据版本存放 ,右边对象都是存放在堆空间里的
```

## 方法区的垃圾回收
```
方法区的垃圾收集主要是:
1.常量池中废弃的常量
2.不再使用的类型

ps: jdk11的ZGC收集器不支持类卸载
```
![方法区的垃圾回收](/img/2020-07-02/50.png)