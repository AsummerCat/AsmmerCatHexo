---
title: synchronized锁升级过程
date: 2020-05-11 15:50:04
tags: [jdk源码解析,synchronized]
---

# synchronized锁升级过程

![](/img/2020-05-09/synchronized.png)

<!--more-->

# 锁升级

```java
->无锁(没有线程执行同步方法的状态)
->偏向锁(不存在资源抢占的情况下)
->轻量锁(针对竞争锁对象线程不多且线程持有锁时间不长的场景) 
->重量锁(操作系统互斥（mutex）实现的)

锁只可以升级不可以降级，但是偏向锁可以被重置为无锁状态。
```

### 1.无锁：

​          MarkWord标志位01，没有线程执行同步方法/代码块时的状态。

### 2.偏向锁：

MarkWord标志位01（和无锁标志位一样）。偏向锁是通过在bitfields中通过CAS设置当前正在执行的ThreadID来实现的。假设线程A获取偏向锁执行代码块（即对象头设置了ThreadA_ID），线程A同步块未执行结束时，线程B通过CAS尝试设置ThreadB_ID会失败，因为存在锁竞争情况，这时候就需要升级为轻量级锁。

**注：偏向锁是针对于不存在资源抢占情况时候使用的锁，如果被synchronized修饰的方法/代码块竞争线程多可以通过禁用偏向锁来减少一步锁升级过程。可以通过JVM参数-XX:-UseBiasedLocking = false来关闭偏向锁。**

### 3.轻量级锁：

**MarkWord标志位00。**轻量级锁是采用自旋锁的方式来实现的，自旋锁分为固定次数自旋锁和自适应自旋锁。轻量级锁是针对竞争锁对象线程不多且线程持有锁时间不长的场景,** 因为阻塞线程需要CPU从用户态转到内核态，代价很大，如果一个刚刚阻塞不久就被释放代价有大。**具体实现和升级为重量级锁过程：**线程A获取轻量级锁时会把对象头中的MarkWord复制一份到线程A的栈帧中创建用于存储锁记录的空间DisplacedMarkWord，然后使用CAS将对象头中的内容替换成线程A存储DisplacedMarkWord的地址。如果这时候出现线程B来获取锁，线程B也跟线程A同样复制对象头的MarkWord到自己的DisplacedMarkWord中，如果线程A锁还没释放，这时候那么线程B的CAS操作会失败，会继续自旋，当然不可能让线程B一直自旋下去，自旋到一定次数（固定次数/自适应）就会升级为重量级锁。

### 4.重量级锁：**通过对象内部监视器（monitor）实现，monitor本质前面也提到了是基于操作系统互斥（mutex）实现的，操作系统实现线程之间切换需要从用户态到内核态切换，成本非常高。**

注：锁只可以升级不可以降级，但是偏向锁可以被重置为无锁状态。**