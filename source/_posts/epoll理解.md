---
title: epoll理解
date: 2020-06-02 19:46:09
tags: [redis,epoll模型]
---

# epoll:


流程:
```
1. 建立socket连接  =文件描述符fd5
2. 绑定端口 
3. 监听端口
4. 创建epoll_create  =文件描述符fd8  (多路复用器)
5. 在文件描述符fd8中添加一个 fd5(也就是socket) 未来是否有人来连接 
epoll_ctl(fd8,add,fd5,accept)
6. 如果 来了一个客户端与socket建立连接->
7. 程序获取:epoll_wait(fd8) 程序接收到事件 ->处理(同步读写)
8. 事件如何获取:
 进入流程:
 网卡收到数据->硬中断CPU(告诉CPU我有事件来了)
 CPU根据文件描述符->回调到->
 事件驱动 (就可以知道那个连接的请求到了)->转移到另外一个区域(这里就可以返回程序 告诉程序哪个连接的内容到了进行处理)
 
 
 epoll: 也就是尽量利用事件驱动 来减少CPU的主动遍历
```

<!--more-->

## redis

```
单线程 利用了epoll->(不管有多少个连接,epoll(多路复用)会告诉redis需要读取哪个)
 事件是原子性的:
  read ->计算 ->返回
  
  
 多线程: 指的是IO thread 部分
 读取资源部分 (epoll已经告诉redis有哪些数据到达了)
 IO多线程读取 不同事件的内容
 计算部分 由(单线程)工作线程去执行(依旧是串行化操作)
 
 A事件计算完成了 
 IO thread进行写入的同时,工作线程(单线程)继续计算另外一个
 
```

![redis的epoll][/img/2020-06-03/redis.png]

