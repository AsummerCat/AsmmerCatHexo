---
title: 面试相关-dubbo
date: 2020-02-17 20:37:11
tags: [面试相关,dubbo]
---

# dubbo



### dubbo的工作原理

```
第一层: service层,        接口层,          主要给生产者和消费者实现
第二层: config层,         配置层,          主要是对dubbo进行各种配置的
第三层: proxy层,       服务代理层,          提供者和消费者 ,dubbo都给你做了代理 (进行网络通信)
第四层: registry层,    服务注册层,          提供者去注册服务,消费者去订阅服务
第五层: cluster层,        集群层,          封装多个提供者 生成一个集群 
第六层: mirror层,         监控层,          对rpc接口的调用次数和调用时间进行监控
第七层: protocol层,    远程调用层,          负责 具体的提供者和消费者的通信  (rpc调用封装)
第八层: exchange层,    信息交换层,          封装请求响应方模式,同步转异步
第九层: transport层,   网络传输层,          抽象mina和netty为统一接口
第十层: serialize层,  数据序列化层
```

<!--more-->

### dubbo的工作流程

```
1. 服务提供者 ->向注册中心注册
2. 消费者->注册中心订阅服务->注册中心会通知消费者 提供方注册好的服务
3. 消费者->调用服务
4. 消费者和提供者都会异步通知 监控中心
```

### dubbo支持的通信协议

```
1.dubbo协议 :默认 单一长连接 ,Nio异步通信,基于hessian做序列化 传输数据量小(100k以内) 但是并发高

2.rmi协议 :  单一短连接,适用文件传输         序列化:java二进制协议   (比较少用)

3.hessian协议 :多个短连接  (比较少用)

4.http协议: 走json序列化

5.websocket: 走soap协议
```

### dubbo支持的序列化协议

```
1.hessian (默认)
2.protobuf
3.java的序列化
4.soap协议

```

### dubbo 的负载均衡策略有几种算法?

```
1.随机  (默认) 根据权重
2.轮询  (也是根据权重)
3.最少活跃请求数
4.一致性hash算法
```

### dubbo支持 高可用(集群容错)策略

```
1.failover cluster模式  失败自动切换  (默认)  常见于读操作
2.failfail cluster模式  一次调用失败就失败了(快速失败)   常见于写操作
3.failsafe cluster模式  出现异常忽略掉,常用于不重要的接口调用  比如日志
4.failbackc cluster模式  失败了后台自动记录请求,然后定时重发, 适用于消息队列
5.forking cluster模式   并行调用多个提供者,只要一成功就返回了

```

### dubbo支持动态代理策略

```
默认使用javassist动态字节码生成,创建代理类

但是可以通过SPI扩展机制 ,来实现自己的动态代理策略
```



# 真题

###注册中心挂了 能不能继续通信?

```
可以
因为刚刚初始化的时候 消费者会将提供者的地址等信息拉取到本地缓存,所以注册中心挂了 也还是能继续通信的
```

### SPI是什么?

```
系统提供服务
比如 A服务 实现 A1 A2 A3 ->配置一下 A=A1 -> 具体执行 根据配置执行

经典实现: java的 jdbc ->是没有实现的,只提供SPI ->根据数据库厂商引入配置
```

### 如何基于dubbo做服务治理,服务降级,失败重试,及其超时重试

```
# 服务治理
1.调用链路自动生成
2.服务访问压力及其时长统计


## 服务降级
 1.创建mock类 执行降级业务
 
## 失败重试


## 超时重试
1. 配置超时的参数 timeout=2000  check=true
2.并且设置重试次数  retries=3     调用失败会重试 

```

### 幂等性保证

```
1.使用数据库主键保证 流水号
2.使用redis 布隆过滤器保证 流水号 
```

### 保证数据的顺序性

```
1.使用分布式锁 来保证业务顺序执行
```

### 如果保证dubbo的可扩展性

```
1. 所有核心组件以接口形式创建 spi机制  去动态的找代理类实现 没有配置就用默认的

2. 提供一个自己实现的组件 基于spi 配置  对于某个组件实现自己的组件
```

### Dubbo消费者如何调用提供者?

```
1. 执行消费者的代理类
2. 然后 获取提供者的地址 进行负载均衡 选取出ip
3. 根据通信协议封装请求 
4. 根据序列化封装消息
5.网络通信 :调用netty请求 提供者的代理类  (NIO)

6.提供者的netty监听请求 
7.提供者反序列化请求
8.提供者处理业务
8.提供者根据通信协议封装请求
9.提供者序列化消息
10.netty发送消息给消费者的channel
```

