---
title: JVM笔记垃圾回收相关算法(二)
date: 2020-07-25 15:04:30
tags: [JVM笔记]
---

# JVM笔记垃圾回收相关算法(二)

# 标记阶段的算法(查找垃圾) 
判断对象存活

判断对象存活一般方式为:  
<font color='red'>
`引用计数算法`和`可达性分析算法` </font>  
该阶段为垃圾标记阶段

### 引用计数器算法
简单来说一个对象被引用一次,引用计数器就+1;  
只要引用计数器为0,就可进行回收了.  

注意: 实现简单,但是无法处理循环引用的情况,导致内存泄露

<!--more-->

![引用计数器算法](/img/2020-07-02/72.png)

### 可达性分析算法 (GC Root)
也称为 根搜索算法   
<font color='red'>
相比较`引用计数算法`  
->最主要的是解决了循环引用的问题,防止内存泄露的发生
</font>    
![可达性分析算法](/img/2020-07-02/73.png)
#### GC Root 
```
根节点:
1.虚拟机栈中引用的对象
2.本地方法栈内引用的对象
3.方法区中类静态属性引用的对象
  比如:字符串常量池的引用
4.方法区中常量引用的对象
5.所有被同步锁(Synchronized)持有的对象
6.JAVA虚拟机内部的引用 
  比如:class对象之类的
等等

注意:
 在GC Root节点找引用的时间段点 会STW 这点是必须的
 不然可能在过程中 引用被移除;
   分析工作必须在一个能保证一致性的快照中进行.
这点也是导致在GC中 `STW`的 一个重要原因   


```
![可达性分析算法](/img/2020-07-02/74.png)



# 清除阶段的算法
常见的三种垃圾收集算法 
```
1.标记清除算法

2.复制算法

3.标记压缩算法
```


### 标记清除 算法
 快速,但是会产生内存碎片   
 标记的时候会`STW`   

 ```
 注意:在标记的环节里:
   被标记的内容是GC Root可达的对象而不是垃圾对象.
   
 ```
![标记清除算法](/img/2020-07-02/75.png)


### 复制 算法
常用于`新生代`垃圾收集的算法  
因为新生代存活的对象比较少 ,大部分都是垃圾对象  
所以使用复制算法.  
如果存活对象很多->  则会导致扫描一遍 又要复制一整个空间一遍

![复制算法](/img/2020-07-02/76.png)  
![复制算法优缺点](/img/2020-07-02/77.png)

### 标记压缩(或标记整理) 算法

![标记压缩算法](/img/2020-07-02/78.png)  
![标记压缩算法优缺点](/img/2020-07-02/79.png)

### 分代收集 算法  (常用 聚合了以上部分)
是一个概念  
几乎所有的JVM虚拟机都是使用分代收集的算法执行垃圾的回收  

根据新生代,老年代进行选择不同的垃圾回收算法   
![分代收集算法](/img/2020-07-02/80.png)


### 增量收集算法 和 分区算法

##### 增量收集算法
![增量收集算法](/img/2020-07-02/80.png)  
![增量收集算法缺点](/img/2020-07-02/81.png)

##### 分区算法  jdk9使用的G1收集器
![分区算法](/img/2020-07-02/82.png)