---
title: 网络协议OSI7层tcp5层
date: 2020-05-08 13:11:16
tags: [网络协议]
---

# 网络模型

## OSI 七层

1.物理层   : 网线 等  能与其他计算机连接的物理设备

2.链路层 : 以太网协议 用来解析(0/1的电路信号) 解析网络数据包内容 定义数据包  (一台电脑的网卡发送给另外一台电脑  mac地址)

3.网络层:  分配IP地址  192.168.1.1  和路由选择

4.传输层:    ip协议  udp和TCP都是传输层的协议 , 在数据包中加入端口号 ->进行点对点通信  (建立连接,如何发送发送和读取消息)  定义传输数据的协议端口号，以及流控和差错校验。

<!--more-->

5.会话层:  建立,管理和维护会话 （在五层模型里面已经合并到了应用层）

6. 表示层: 表示层主要是解释通讯数据的意义，如代码转换、格式变换等，使不同的终端可以表示。

   还包括加密与解密、压缩与解压等。   （在五层模型里面已经合并到了应用层）

   

7. 应用层 : 为程序提供服务 

![](/img/2020-05-09/TCP模型.png)



## TCP5层  

就是将后面的 会话层,表示层,应用层 整合为一个应用层

4层: 链路层(以太网协议) ,网络层(ip协议),传输层(tcp协议),应用层(Http协议)

应用层:  用HTTP协议进行数据解析,网络通信   ->用来处理传输层发送过来的数据key value  



# TCP的三次握手,四次挥手



## 三次握手

1. 客户端发送 握手请求: SYN=1 AKC=0 SEQ=X
2. 服务端返回 握手请求: ACK=X+1,SYN=1,ACK=1,SEQ=Y
3. 客户端接收消息后再次发送握手请求 ack=y+1,ack=1,seq=x+1

然后就建立连接了

## 为不是不是两次握手 而要三次

1.两次握手 可能会出现这个情况(资源浪费)

```
如果客户端第一次发送握手消息 卡在半路了,
客户端会重新发送一次握手消息
服务端返回握手 连接建立

然后 第一次卡在半路的握手消息 又发送到服务端了,
服务端就开辟了一个新的接收请求的区域,然后返回给客户端,
由于客户端已经与服务端建立了tcp连接了 ,
不认第一次的握手消息,而服务端又开启了一块新的区域,造成了浪费


***************
如果是三次握手的话 
第一次失败的握手消息成功发送给服务器后,服务器返回握手,
客户端这边,会发送一个复位的消息(复位连接)给服务端,
让服务端撤回已经开启的空间
**************
```

三次就够了 三次以上浪费资源

## 四次挥手

```
1.第一次挥手 :
 客户端发送挥手消息 FIN=1,SEQ=U,进入了FIN-WAIT-1的状态

2.第二次挥手 :
服务端接收到挥手消息->进入CLOSE_WAIT的状态
,服务端发送挥手消息  ACK=1,ACK=U+1,SEQ=V
客户端接收到报文之后,直接进入FIN-WAIT-2状态,
此时客户端到服务端的连接就释放了

3.第三次挥手:
服务端发送连接释放报文,fin=1,ack=u+1,seq=w,
服务端进入LAST-ACK状态

4.第四次挥手:
客户端收到连接释放报文后,发应答报文,ack=1,ack=w+1,seq=u+1,
进入TIME_WAIT状态,等待一会客户端进入CLOSED状态
,服务端接收到报文后进入CLOSED状态
```

