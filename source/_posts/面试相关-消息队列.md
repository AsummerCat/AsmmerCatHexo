---
title: 面试相关-消息队列
date: 2020-02-04 00:01:48
tags: [面试相关,消息队列]
---

# 消息队列

### 作用

```
作用: 异步、削峰、解耦
```

### 消息类型

```
1. 发布订阅模型
2. 点对点模型 
```

### rabbitMQ 和kafka区别

```
rabbitMQ  集群模式  :   普通集群模式(路由到源数据的mq)    镜像模式(纯同步)

kafka    天生分布式    每个topic可以指定多个partition    每个mq一个partition 也就是说 一个topic的消息会被分配到多个mq里面  比如 A 2个消息 B 3个消息

  |HA机制  : 0.8版本以后 有一个副本机制->生成副本partiion被在其他机子(follower)上会生成副本  并进行选举
    写入lader同步到follower
```



### 顺序消费

```
1.保证消息都投递到一个队列中 ,并且只有一个消费者
```

<!--more-->

# 真题

### 如何保证rabbitMQ不会消息丢失?

```
生产者:  1.添加事务 try catch 保证消息发送成功  可以回滚重试  (不推荐 会卡mq 降低性能)
        2.confirm机制  设置channel设置为confirm模式 发送消息 mq确认 mq回调发送结果是否成功 失败重试

消息队列:  3.消息持久化    两步(queue持久化  消息持久化)
          4.设置集群镜像模式 HA方案

消费者:   5.消息补偿机制  发送消息添加事务写入数据库 让DB发送给mq 发送成功后 删除记录   
         6.ACK确认机制

```

###  如何保证kafka不会消息丢失?

```
消费者:   1.关闭自动提交offset 并且保证幂等性处理

消息队列: 2. 问题: 数据进入mq 还没同步就挂掉 选举上来的mq没有该数据
        | 解决方案: 
        ||2.1设置参数: 给topic设置 replication.factor参数>1 :保证每个partition必须至少有2个副本
        ||2.2 kafaka服务端设置min.insync.replicas参数 :必须大于1这个是要求一个leader至少感知到1个副本还跟自己联系
        
生产者:        
        ||2.3 在生产者端设置acks=all :要求每条数据必须写入所有副本之后才认为成功
        ||2.4 在生产者端设置retries=一个很大的值(MAX) :要求一旦写入失败,就无限重试,卡在这里
                          
```





### 你觉得它有什么缺点吗？或者说怎么考虑用不用消息队列？

```
1.系统可用性降低： 系统可用性在某种程度上降低，为什么这样说呢？在加入 MQ 之前，你不用考虑消息丢失或者说 MQ 挂掉等等的情况，但是，引入 MQ 之后你就需要去考虑了！
2.系统复杂性提高： 加入 MQ 之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！
3.一致性问题： 我上面讲了消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了!
```

### Mq消息积压处理?

```
1.如果仅仅是consumer消费的速度落后于消息生产的速度的话，可以考虑采用扩容消费者群组的方式。

2.如果堆积了上百万的消息 
      |先修复消费者的问题，确保其恢复消费速度，然后将现有消费者都停掉
      |可以创建10倍队列数 或者20倍
      |创建个临时的消费者 消费消息写入新的10倍队列中 (这边也可将原来的消费者进行临时修改,处理完毕再改回去)
      |接着临时征用10倍的机器来部署consumer，每一批consumer消费一个临时queue的数据。
      |然后处理完毕 再调用原先的架构来处理
      
 3.如果磁盘满了无法处理 临时写程序效率慢 那么先快速消费所有数据 然后再走第二套方案 ,晚上补数据   
```

### mq满了怎么处理?

```
如果磁盘满了无法处理 临时写程序效率慢 那么先快速消费所有数据(不处理) 晚上补单
```

### rabbitMQ消息大批量过期如何处理?

```
消息积压时间过长 消息丢失
生产环境尽量不设置过期 解决比较麻烦

解决方案:
1.这边可以利用死信队列 再给他捞回来
2.或者说手动写个程序 抓取出丢失的消息 再发给mq 继续消费 类似于补单的操作

```





### 如何保证高可用?

```
1.消息持久化
2.ACK机制
3.MQ高可用 HA方案    集群模式(随意访问 路由到源数据的机子) 或者镜像集群模式(拷贝完整数据)
4.消息补偿机制 如DB
```

### 处理重复消费的问题 或者保证消息消费幂等性问题? 

```
kafka中 有个offset的概念 -> 
 消费端重复消费问题:   消费者 消费数据后 将顺序标记的序号 传入给zk zk标记后 客户端重启 后接着标记消费
 
 
解决方案: 1.弱检查   在redis中保存消费的id  如果存在就不消费 订单号+业务场景(做主键)  解决幂等性
         2.强检查   存入DB 进行判断  比如 唯一主键
```

### 如何保证 消费者 顺序消费?

```
错误情况:
   1.rabbitmq : 一个queue ,多个consumer 这不明显乱了
   2.kafaka: 一个topic,多个partition,多个consumer 内部多线程 这不明显乱了
   
解决方案:
   1.rabbitmq: 一个queue对应一个consumer ,或者拆分多个queue对应多个consumer 
   
   2.kafka: 一个topic,一个partition ,一个consumer 内部单线程消费, 写N个内存queue(java的阻塞队列 同一订单号放入同一个queue),然后N个线程分别消费一个queue即可
```

### 如果让你设计一个中间件 你会如何设计?

```
1. 需要有 ACK设置
2. 需要支持可伸缩
3.mq数据要落地 持久化
4.支持高可用 如选举方案
5. 需要经历支持数据0丢失  等等

```

