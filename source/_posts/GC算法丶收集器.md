---
title: GC算法丶收集器
date: 2018-12-07 17:18:35
tags: JVM
---

#  GC算法

## 复制算法  （新生代的GC）
复制算法是先将内存分为两个部分  
*  一部分用来放入对象   
*  而另一部分暂时不用  


当使用的一部分内存要进行垃圾回收的时候会将不需要回收的对象复制保存在另一个空间中，然后再对使用过的那部分区域进行垃圾回收，这样虽然效率很高，但是很浪费空间，所以一般将新生代分为Eden空间和两个Survivor空间，其大小在HotSpot虚拟机中默认比例为8：1：1，这样在新生代中采用复制算法回收垃圾效率就很高了  

![复制算法](/img/2018-12-7/GC算法-复制算法前.png)  
![复制算法](/img/2018-12-7/GC算法-复制算法后.png)  



<!--more-->

## 标记-清除算法

首先标记出要进行GC的对象，标记完成后再进行GC。这种算法效率不高，并且会产生很多内存碎片。  
![标记-清除算法](/img/2018-12-7/GC算法-标记清除算法前.png)  
![标记-清除算法](/img/2018-12-7/GC算法-标记清除算法后.png)  



## 标记-整理算法 （老年代的GC）

标记-整理算法：同样是先对要进行GC的对象进行标记，但是不同的是在标记完成后不是立刻执行GC，而是先将不需要GC的对象移动到一端，然后在边界外再对要回收的对象进行GC。  

![标记-整理算法](/img/2018-12-7/GC算法-标记整理算法前.png)  
![标记-整理算法](/img/2018-12-7/GC算法-标记整理算法后.png)



## HotSpot虚拟机GC算法采用分代收集算法

存活率低：少量对象存活，适合复制算法：在新生代中，每次GC时都发现有大批对象死去，只有少量存活（新生代中98%的对象都是“朝生夕死”），那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成GC。

存活率高：大量对象存活，适合用标记-清理/标记-整理：在老年代中，因为对象存活率高、没有额外空间对他进行分配担保，就必须使用“标记-清理”/“标记-整理”算法进行GC。

---
---
---

# GC收集器

<font color="red">在介绍垃圾收集器之前，需要明确一点，就是在新生代采用的停止复制算法中，“停 止（Stop-the-world）”的意义是在回收内存时，需要暂停其他所 有线程的执行。这个是很低效的，现在的各种新生代收集器越来越优化这一点，但仍然只是将停止的时间变短，并未彻底取消停止。</font>  

## Serial收集器  串行 (单线程)

> 它只有一条GC线程，且就像前面说的，它在运行的时候需要暂停用户程序（stop the world）。





## parallel 收集器 并行  (多线程)

> 它有多条GC线程，且它也需要暂停用户程序（stop the world）。





## concurrent 收集器 并发

>它有一条或多条GC线程，且它需要在部分阶段暂停用户程序（stop the world），部分阶段与用户程序并发执行。  
>大白话就是 普通线程 和收集器一起工作


## hotspotJVM 收集器实现

```JAVA
   我们上面已经简单探讨了垃圾搜集器的分类，在hotspotJVM中，每一个种类的垃圾搜集器都有对应的实现，如下。

   串行搜集器的实现：serial（用于新生代，采用复制算法）、serial old（用于年老代，采用标记/整理算法）

   并行搜集器的实现：ParNew（用于新生代，采用复制算法）、Parallel Scavenge（用于新生代，采用复制算法）、Parallel old（用于年老代，采用标记/整理算法）

   并发搜集器的实现：concurrent mark sweep[CMS]（用于年老代，采用标记/清除算法）
```





---
---
---