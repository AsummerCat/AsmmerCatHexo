---
title: GC算法丶收集器
date: 2018-12-07 17:18:35
tags: [jvm,数据结构与算法]
---

#  GC算法

## 复制算法  （新生代的GC）
复制算法是先将内存分为两个部分  
*  一部分用来放入对象   
*  而另一部分暂时不用  


当使用的一部分内存要进行垃圾回收的时候会将不需要回收的对象复制保存在另一个空间中，然后再对使用过的那部分区域进行垃圾回收，这样虽然效率很高，但是很浪费空间，所以一般将新生代分为Eden空间和两个Survivor空间，其大小在HotSpot虚拟机中默认比例为8：1：1，这样在新生代中采用复制算法回收垃圾效率就很高了  

![复制算法](/img/2018-12-7/GC算法-复制算法前.jpg)  
![复制算法](/img/2018-12-7/GC算法-复制算法后.png)  



<!--more-->

## 标记-清除算法

首先标记出要进行GC的对象，标记完成后再进行GC。这种算法效率不高，并且会产生很多内存碎片。  
![标记-清除算法](/img/2018-12-7/GC算法-标记清除算法前.png)  
![标记-清除算法](/img/2018-12-7/GC算法-标记清除算法后.png)  



## 标记-整理算法 （老年代的GC）

标记-整理算法：同样是先对要进行GC的对象进行标记，但是不同的是在标记完成后不是立刻执行GC，而是先将不需要GC的对象移动到一端，然后在边界外再对要回收的对象进行GC。  

![标记-整理算法](/img/2018-12-7/GC算法-标记整理算法前.png)  
![标记-整理算法](/img/2018-12-7/GC算法-标记整理算法后.png)



## HotSpot虚拟机GC算法采用分代收集算法

存活率低：少量对象存活，适合复制算法：在新生代中，每次GC时都发现有大批对象死去，只有少量存活（新生代中98%的对象都是“朝生夕死”），那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成GC。

存活率高：大量对象存活，适合用标记-清理/标记-整理：在老年代中，因为对象存活率高、没有额外空间对他进行分配担保，就必须使用“标记-清理”/“标记-整理”算法进行GC。

---
---
---

# GC收集器

<font color="red">在介绍垃圾收集器之前，需要明确一点，就是在新生代采用的停止复制算法中，“停 止（Stop-the-world）”的意义是在回收内存时，需要暂停其他所 有线程的执行。这个是很低效的，现在的各种新生代收集器越来越优化这一点，但仍然只是将停止的时间变短，并未彻底取消停止。</font>  

## Serial收集器  串行 (单线程)

> 它只有一条GC线程，且就像前面说的，它在运行的时候需要暂停用户程序（stop the world）。





## parallel 收集器 并行  (多线程)

> 它有多条GC线程，且它也需要暂停用户程序（stop the world）。





## concurrent 收集器 并发

>它有一条或多条GC线程，且它需要在部分阶段暂停用户程序（stop the world），部分阶段与用户程序并发执行。  
>大白话就是 普通线程 和收集器一起工作


## hotspotJVM 收集器实现

```
   我们上面已经简单探讨了垃圾搜集器的分类，在hotspotJVM中，每一个种类的垃圾搜集器都有对应的实现，如下。

   串行搜集器的实现：serial（用于新生代，采用复制算法）、serial old（用于年老代，采用标记/整理算法）

   并行搜集器的实现：ParNew（用于新生代，采用复制算法）、Parallel Scavenge（用于新生代，采用复制算法）、Parallel old（用于年老代，采用标记/整理算法）

   并发搜集器的实现：concurrent mark sweep[CMS]（用于年老代，采用标记/清除算法）
```





## 垃圾收集器选择参数


​          **UseSerialGC**：开启此参数使用serial & serial old搜集器（client模式默认值）。  

​          **UseParNewGC**：开启此参数使用ParNew & serial old搜集器（不推荐）。  

​          **UseConcMarkSweepGC**：开启此参数使用ParNew & CMS（serial old为替补）搜集器。  

​          **UseParallelGC**：开启此参数使用parallel scavenge & parallel old搜集器（server模式默认值）。  

​          **UseParallelOldGC**：开启此参数在年老代使用parallel old搜集器（该参数在JDK1.5之后已无用）。

  

## 垃圾收集器性能通用参数

 **PretenureSizeThreshold**：晋升年老代的对象大小。默认为0，比如设为10M，则超过10M的对象将不在eden区分配，而直接进入年老代。  

​          **MaxTenuringThreshold**：晋升老年代的最大年龄。默认为15，比如设为10，则对象在10次普通GC后将会被放入年老代。  

​          **DisableExplicitGC**：禁用System.gc()。  

## 并行搜集器参数


​          **ParallelGCThreads**：回收时开启的线程数。默认与CPU个数相等。   

​          **GCTimeRatio**：设置系统的吞吐量。比如设为99，则GC时间比为1/1+99=1%，也就是要求吞吐量为99%。若无法满足会缩小新生代大小。   

​          **MaxGCPauseMillis**：设置垃圾回收的最大停顿时间。若无法满足设置值，则会优先缩小新生代大小，仍无法满足的话则会牺牲吞吐量。 

## 并发搜集器参数

​        **CMSInitiatingOccupancyFraction**：触发CMS收集器的内存比例。比如60%的意思就是说，当内存达到60%，就会开始进行CMS并发收集。

​          **UseCMSCompactAtFullCollection**：这个前面已经提过，用于在每一次CMS收集器清理垃圾后送一次内存整理。

​          **CMSFullGCsBeforeCompaction**：设置在几次CMS垃圾收集后，触发一次内存整理。

---

# 总结

本篇文章只是做一个罗列