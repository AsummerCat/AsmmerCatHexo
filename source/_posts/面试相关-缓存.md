---
title: 面试相关-缓存
date: 2020-02-03 22:15:59
tags: [java,面试相关]
---

## 缓存

```
缓存分为 本地缓存 多级缓存 分布式缓存
```

### 淘汰策略

```
淘汰策略: FIFO(先进先出)   
         LRU(最近最少使用数据)   
         LFU(最低使用频率的数据)
```

### 缓存问题处理

<!--more-->

```
缓存问题处理: 
       1.缓存不一致
            数据变更,缓存时效性   增加重试,补偿任务,最终一致  尝试在代码中操作的时候先更新DB再更新缓存
       
       2.缓存穿透
              恶意攻击         空对象做缓存, 使用布隆过滤器->不存在直接返回NULL
         
       3.缓存击穿
             热点key失效        互斥更新,随机退避,差异失效时间 比如加上一个锁 或者CAS操作
         
       4.缓存雪崩
            缓存宕机或者大批量的key失效           缓存宕机:   快速失败熔断,主从模式,集群模式
                                        大批量的key失效:   那就设置不同的过期时间避免同一时间段失效
         
```



## redis

### 好处

```
好处:   单线程 使用多路I/O复用模型，非阻塞IO(IO多路复用)  支持持久化 多数据结构
```

### 6.0以后采用IO多线程模型

http://antirez.com/news/126

```
网络通信仍然使用单线程模型  ->IO处理部分使用多线程, 其他模块也是多线程
(Redis 的多线程部分只是用来处理网络数据的读写和协议解析)

引入原因:
  目前对于单线程 Redis 来说，性能瓶颈主要在于网络的 IO 消耗，优化主要有两个方向:
1、提高网络 IO 性能，典型的实现像使用 DPDK 来替代内核网络栈的方式
2、使用多线程充分利用多核，典型的实现像 Memcached
```



### 数据结构

```
数据结构 :
      String: 任何数据      例如: 封锁id和访问次数
      hash:   存储对象      例如: 用户信息
      list:   字符串列表    例如: 最新消息的排行 ,利用list的push将任务存在list中 再用pop读取 模拟队列
      set:    无序集合      例如: 微博好友列表 去重  共同好友取交集
      zset:   有序集合      例如: 根据某个条件进行排序 例如商品列表排序
      
      还有其他的
      bitmap: 用来实现布隆过滤器
      HyperLogLog: 提供 不精确的去重计数功能
      
```

### 数据过期策略及其淘汰策略方式

```
 默认是 : 定期删除+惰性删除
  1. 定期删除 -> 默认100ms 开始随机检查一批设置过期的key ,过期就删除了 (检查过期key 是随机 不是遍历全部)
  2.惰性删除 -> 访问到这个key 再去判断是否过期了 过期就删除了
  3.如果上面两种方式还处理不掉过期的数据 那就要走内存淘汰机制了
  4.在redis内存占用过高的情况下 会进行数淘汰机制处理
     淘汰策略:   
        1.noeviction     ->redis内存不够的时候,插入新数据报错   (基本没人用 默认)
        2.allkeys-lru    ->redis内存不够的时候,删除掉最近最少使用的key  (常用)
        3.allkeys-random ->redis内存不够的时候,随机删除部分key 
        4.volatile-lru   ->redis内存不够的时候,在设置过期时间的key里面,删除最近最少使用的key (一般不太合适)
        5.volatile-ttl：  ->key 的剩余寿命 ttl 的值，ttl 越小越优先被淘汰,即淘汰将要过期的数据.
        6.volatile-random ->redis内存不够的时候,从已设置过期时间的数据集中随机选择数据淘汰

 ##配置方式:
maxmemory-policy volatile-lru   #默认是noeviction，即不进行数据淘汰
  
```

### 手写LRU算法

利用LinkedHashMap 实现

```

public class UseLinkedHashMapCache<K,V> extends LinkedHashMap<K,V>{
    private int cacheSize;
    public UseLinkedHashMapCache(int cacheSize){
    //构造函数一定要放在第一行
     super(16,0.75f,true);    //那个f如果不加  就是double类型，然后该构造没有该类型的入参。 然后最为关键的就是那个入参 true   这个参数是表示按照最近访问次数来排序的
     this.cacheSize = cacheSize;
    }

    @Override
    protected boolean removeEldestEntry(Map.Entry<K,V> eldest){   //重写LinkedHashMap原方法
         return size()>cacheSize;  //临界条件不能有等于，否则会让缓存尺寸小1
    }   
}
```



### 集群架构 (高可用,高并发)

```
1.Redis Cluster集群架构
  |集群节点最小配置 6 个节点以上(3 主 3 从)，其中主节点提供写操作,从节点读取
  |采用虚拟槽分区，所有的键根据哈希函数映射到 0～16383 个整数槽内，每个节点负责维护一部分槽以及槽所印映射的键值数据。
  |无中心架构;
  |数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布;
  |可扩展性：可线性扩展到 1000 多个节点，节点可动态添加或删除;
  |高可用性：部分节点不可用时，集群仍可用。通过增加 Slave 做 standby 数据副本，能够实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave 到 Master 的角色提升;
  |实现了: 多master+读写分离+高可用
  |与哨兵比较
    ||整个流程跟哨兵相比，非常类似，所以说，redis cluster 功能强大，直接集成了 replication 和 sentinel 的功能。


2.主从架构(需要保证master节点必须持久化)   高可用: master节点挂了->故障转移->主备切换
  |主从复制方案: 第一次slave节点 全量复制 之后是断点续传
  |如果断开长时间会直接生成rdb文件复制给slave 
  |如果多个slave都来重新连接,那么只会有一个rdb save数据来服务所有slave 
  |无磁盘复制: 如果开启这个选项 在master会在内存中生成一个rdb来发送给slave  而不会落在本地磁盘上
       |配置:repl-diskless-sync no   -> yes 为开启
       |    repl-diskless-sync-delay ->等待多久发送一次
       
  
  
  
3.哨兵架构
   |作用:集群监控,消息通知,故障转移,配置中心
   | 哨兵需要最少3个实例 来保证健壮性
   |通过选举来切换mater节点
   |配置几个哨兵认为宕机 进行切换 :quorum=1
   |选举出的节点规则:
       ||根据优先级排序 参数:slave-priority 越小 越优先
       ||slave-priorit相等 ->在根据复制数据的offset 来选择 复制越多数据的优先
       ||offset相等 ->  选取一个run id比较小的那个作为master
       ||如果切换失败了 等待failover-time时间 再重新选举
   
 4.宕机后,切换节点需要保证数据不丢失:
    |丢失原因: 
            ||异步复制失败导致的数据丢失  
            ||脑裂(master没挂 但是连接不上,好了之后client还没来得及切换节点写入)导致的数据丢失
    |添加参数: 
            ||两个参数要求了 :最少需要有一个slave,数据复制和同步的延迟不能超过10秒
            ||min-slaves-to-write 1    保证了最少需要有要给一个slave节点发送数据
            ||min-slaves-max-log 10    保证了如果10秒内没有slave给自己ack那么拒绝客户端写请求
              
    脑裂情况下:如果发送丢失 最多丢失10秒的数据           



5.高可用需要:  master节点挂了->故障转移->主备切换   也就是需要主从架构+哨兵模式

```

### 主从复制的流程

```
1.slave里面仅仅保存了master节点的相关信息
2.slave有个定时任务 1秒check一次mater节点是否有新数据 如果有建立socket连接
3. 如果有口令认证 那久认证一下
4.第一次复制 全量复制 (默认60秒内 大于失败 可以设置参数调整),后续异步 断点续传
```

# redis的集群模式(Redis Cluster)

### redis的集群模式的工作原理

```
1.自动将数据进行分片，每个 master 上放一部分数据
2.提供内置的高可用支持，部分 master 不可用时，还是可以继续工作的
```

### 集群模式下的key是如何寻址的?分布式寻址算法有3种

```
分布式寻址算法:
    1.hash 算法（大量缓存重建）
    2.一致性 hash 算法（自动缓存迁移）+ 虚拟节点（自动负载均衡）
    3.redis cluster 的 hash slot(槽) 算法
```

#### redis cluster 的 hash slot(槽) 算法

```
1.有固定的16384个hash槽,对每个key进行CRC16计算,然后对16384进行取模,可以获取key对应的hash slot
2.每个master都会获取部分hash槽,如3个master,每个master都会有5000个左右的hash槽
3.hash slot的增加和移除很简单,增加一个master,移动部分hash slot给他,移除一个,将hash slot 移动给其他master
```

### 了解一致性hash算法么?

```
大致意思就是: 将hash值空间组成一个虚拟圆环->node节点分布其中->根据顺时针计算key的位置离哪个节点最近挂靠其中,
动态删除:将原有挂靠移动到下一个最近的节点
动态添加:根据hash算法获取到key 映射到新增的node节点上
```

```
一致性 hash 算法将整个 hash 值空间组织成一个虚拟的圆环，整个空间按顺时针方向组织，下一步将各个 master 节点（使用服务器的 ip 或主机名）进行 hash。这样就能确定每个节点在其哈希环上的位置。

来了一个 key，首先计算 hash 值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，遇到的第一个 master 节点就是 key 所在位置。

在一致性哈希算法中，如果一个节点挂了，受影响的数据仅仅是此节点到环空间前一个节点（沿着逆时针方向行走遇到的第一个节点）之间的数据，其它不受影响。增加一个节点也同理。

然而，一致性哈希算法在节点太少时，容易因为节点分布不均匀而造成缓存热点的问题。为了解决这种热点问题，一致性 hash 算法引入了虚拟节点机制，即对每一个节点计算多个 hash，每个计算结果位置都放置一个虚拟节点。这样就实现了数据的均匀分布，负载均衡。
```

### 如何动态添加和删除一个节点?

```
动态删除: 比如 node2失效 挂靠的几个key 会顺时针转移到下一个节点
动态添加: 比如添加一个node4节点 ,根据hash算法获取到key4 映射到环上
```



### 持久化方案

```
持久化:
   1.AOF: 操作日志   (热备)
         ||优点: 通过aof日志回放 ->保证尽可能的少的数据丢失  一般1秒进行一个fsync操作,最多丢失一秒 
         ||缺点: 占空间,恢复备份速度慢  数据恢复(比如执行flushall) 如果存在部分BUG则导致无法恢复  
  
   
   2.RDB: 快照数据写入磁盘  主线程fork一个子线程进行RDB备份  (冷备)
         ||优点:  节省磁盘空间  恢复速度快  可定时备份到oss空间
         ||缺点: 最后一次持久化后数据丢失  如果fork线程->数据过大,可能导致redis暂停对外服务数秒
         
   3.持久化保证数据不丢失的话 尽可能两种方案同时使用      
```

### redis集群 内部通信原理

```
1.redis cluster节点采用gossip协议进行通信
2.需要有单独的通信节点 发送ping 获取其他节点的pong
3.交换的信息 ->故障转移,节点的增加和删除,hash slot信息 等等
```





### redis的分布式方案

```
使用redison框架 来实现redis的分布式操作 
基于lua操作
```

## zk

### zk的作用

```
统一配置管理、统一命名服务、分布式锁、集群管理
例如dubbo用zk做注册中心
```



### zk的分布式锁方案

```
分布式方案 curator
使用临时顺序节点来控制锁
```



# 真题

### 分布式锁的选择

```
redis:  redisson
zk:     curator 
```

