---
title: 面试相关-JVM
date: 2020-02-03 22:45:39
tags: [面试相关,JVM]
---

## JVM

### 内存模型

```
线程独占   ->本地方法栈  栈 程序计数器
线程共享   ->堆  方法区 1.8使用元空间(Metaspace) 


栈:  又称方法栈,线程私有的,线程执行方法是都会创建一个栈帧,用来存储局部变量表,操作栈,动态链接,方法出口等信息.调用方法时执行入栈,方法返回式执行出栈.

本地方法栈: 与栈类似,也是用来保存执行方法的信息.执行Java方法是使用栈,执行Native方法时使用本地方法栈.

程序计数器: 保存着当前线程执行的字节码位置,每个线程工作时都有独立的计数器,只为执行Java方法服务,执行Native方法时,程序计数器为空.

堆:JVM内存管理最大的一块,对被线程共享,目的是存放对象的实例,几乎所欲的对象实例都会放在这里,当堆没有可用空间时,会抛出OOM异常.根据对象的存活周期不同,JVM把对象进行分代管理,由垃圾回收器进行垃圾的回收管理

方法区:   它用于存储已被虚拟机加载的类信息, 常量, 静态变量, 即时编译器编译后的代码等数据。
```

 <!--more-->

### volatile

- ```
  - 可见性保证：强制变量的赋值会刷新回主内存，强制变量的读取会从主内存中重新加载，保证不同的线程总是能看到该变量的最新值。
  - 有序性保证：通过指令重排序保证变量读写的有序性
  ```

### JVM加载顺序

![JVM加载顺序](/img/2020-02-03/5.png)

```java
深绿色表示加载过程，浅绿色表示生命周期。

加载：通过类的完全限定名找到字节码文件，通过字节码文件创建class对象。

验证：图中始终验证方法。

准备：为static修饰的变量分配内存，初始值0或者null。（final不分配，因为在编译时已经分配）

解析：图中。

初始化：看图中解释，若类的父类没有初始化，则先初始化父类的静态块和静态变量，只有对类的主动使用时才会初始化。

初始化的出发条件：创建类实例、访问类静态变量或者静态方法、class.forName()发射加载、某个子类被初始化。
使用：实例化。

卸载：java前三种类加载器的加载的类不会被卸载，用户自定义类加载器加载的类才会被卸载。
```

### 类加载器与加载模式

![JVM加载顺序](/img/2020-02-03/7.png)

```java
类加载器：启动类加载器、扩展类加载器、应用/系统加载器、用户自定义加载器。

双亲委派模式好处：

避免类的重复加载；
防止java系统类被篡改。
```



### GC区域分块

```
分代回收
   新生代 -> minorGC
   老年代  -> FUllGC
```

### 回收算法

```
应用记数算法 (不推荐)
复制算法 ->新生代
标记删除算法 ->老年代
标记整理算法 ->老年代
标记压缩算法->老年代
标记整理压缩算法->老年代
```

### JVM回收器

```
新生代回收器：SerialGC ParNewGc ParallelScavengeGC
名称	                  串行/并行/并发	回收算法	适用场景	         可以与cms配合
SerialGC	                   串行	      复制	   单cpu   	          是
ParNewGC	                   并行	      复制	   多cpu    	          是
ParallelScavengeGC	         并行	      复制	   多cpu且关注吞吐量	    否

三种老生代回收器
名称	                  串行/并行/并发	回收算法	适用场景
SerialOldGC	                串行	   标记整理	  单cpu
ParNewOldGC	                并行	   标记整理	  多cpu
CMS	并发，几乎不会暂停用户线程	标记清除	多cpu且与用户线程共存
CMS收集器的优点：并发收集、低停顿

G1收集器 分块收集 1.9默认的垃圾回收机制
G1适合对最大延迟有要求的场合，ZGC适合64位对大内存有要求的场合

还有一个ZGC收集器 11提供 是一个可伸缩的、低延迟的垃圾收集器
停顿时间不会超过10ms
停顿时间不会随着堆的增大而增大（不管多大的堆都能保持在10ms以下）
可支持几百M，甚至几T的堆大小（最大支持4T）

```



# 真题

##  **JDK8中永久代向元空间的转换原因**

```
1、字符串存在永久代中，容易出现性能问题和内存溢出。

2、类及方法的信息等比较难确定其大小（比如动态加载类时），因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。
```

## 编译期会对指令做什么操作?

```
指令重排 优化执行效率
如A 和 B 无关 可以调整执行顺序
如果 C 必须执行在AB之后 则无法重排
```

## 什么情况下会造成fullGC

```
新生代晋升
老年代空间不足
永久代空间不足
```

## 简单描述下volatile能解决什么问题?

```
强制主内存读写同步，防止指令重排序
根据volatile的可见性保证 和有序性保证  读取volatile的内容直接读取到内存里的
```

## 对象引用有几种?

```
强引用：不会被GC回收
弱引用：每次GC都会被回收
虚引用：必须和引用兑现联合使用，跟总一个对象被垃圾回收的过程
软引用：空间不足会被GC回收
```

## 使用过哪些JVM调试工具

```
JPS: 查看java进程
jstack: 线程分析工具

```

## JVM执行模式有几种?

```
解释执行   不经过jit直接由解释器解释执行所有字节码  ->字节码翻译成本地码再执行
编译执行   判断是否 "热点代码" 是的话直接走JIT编译执行 机器码
混合执行   新版本的jvm默认都是采用混合执行模式
```

## GC算法的实现和适用场景

```
CMS: 以获取最短回收停顿时间为目标的收集器
G1:  G1适合对最大延迟有要求的场合
ZGC: ZGC适合64位对大内存有要求的场合
```

## 类加载过程

```
加载: 文件加载到JVM
验证: 验证 字节码,文件格式,元数据,符号引用
准备: 准备类变量的内存
解析: 解析 引用替换,字段解析,接口解析,方法解析
初始化: 静态块,静态变量
使用: 实例化
卸载: GC

Java自带的加载器加载的类,在虚拟机的生命周期中是不会被卸载的,只有用户自定义的加载器加载的类才可以被卸.
```

## JVM加载类的机制

```
双亲委派机制
          即加载器加载类时先把请求委托给自己的父类加载器执行,直到顶层的启动类加载器.父类加载器能够完成加载则成功返回,不能则子类加载器才自己尝试加载.
   优点:
         1.避免类的重复加载
         2.避免Java的核心API被篡改
```

## 

## 