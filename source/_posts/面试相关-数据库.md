---
title: 面试相关-数据库
date: 2020-02-03 20:51:06
tags: [面试相关,数据库,java]
---

## 数据库相关

### 数据库 三范式

```
第一范式(最低)
要求表中的字段不可再拆分
第二范式
在满足第一范式的基础上,要求每条记录由主键唯一区分,记录中的所有属性都依赖与主键
第三范式
在满足第二范式的基础上,要求所有属性直接依赖于主键,不允许间接依赖
```

<!--more-->9

### 锁分类

  <font color="red">行锁和表锁是概念 ,共享锁和排他锁是具体实现</font>

```java
锁的分类:
   行锁 (操作关于主键)
   表锁 (主键不明确)      
区别: 行锁是限制当行数据的操作,表锁是限制表的数据操作     
```

### 锁算法

```java
行锁算法:
      1.Record Lock(普通行锁)
             * 键值在条件范围内
             * 记录存在
      2.Gap Lock (间隙锁)
             * 对于键值不存在条件范围内 叫做(间隙) 引擎就会对间隙加锁 就是GAP机制
      3.Next-Key Lock (行&间隙锁)
             例如:
            id只有50 
              select * from user where id>49 for update
                
表锁算法:
       1.意向锁(锁升级机制):
           * 当一个事务带着表锁 去查询一个加了行锁的资源 那么行锁就回升级为意向锁 将表锁住
           例如:
            ==========================================
              事务A: 升级表锁
     select * from user where id =9 for update
              事务B: 表锁
     select * from user where name like'%9%' for update
       这样事务A就会升级为意向锁
            ==========================================  
       
       2.自增锁:
           * 事务插入自增类型的列时,获取自增锁
               | 如果一个事务正在往表插入自增记录,其他事务必须等待

```

### 锁操作

```java
锁的操作:
      1.排他锁(X)  概念:不能获取任何锁 能读                    操作:for update
             ============================================
               例如: 
                   update ...    for update
                   insert ...    for update
                   delete ...    for update
                   select ...    for update 
             ===============================================
                     
      2.共享锁(S)  概念: 能读 不能写                         操作: lock in share mode
           mysql8.0以上 for share 代替了 lock in share mode  但是仍然支持该操作
             ===============================================
             例如:
        select ...  lock in share mode
             ==============================================
          
     3.乐观锁
          一般通过版本号进行更新操作
            ===============================================
             例如:
        update user set name='111' where id=1 and version=1;
             ==============================================
          
     4.悲观锁     
          是排他锁的实践
               
```

### 关系型数据库的四个特性

```
关系型数据库的四个特性:
       一致性  (事务开始和结束之间的中间状态不会被其他事务看到)
       原子性  (记录之前的版本，允许回滚)
       隔离性  (适当的破坏一致性来提升性能与并行度 例如：最终一致~=读未提交。)
       持久性  (每一次的事务提交后就会保证不会丢失)
```

### 数据库的隔离级别

```
MySQL事务隔离级别

事务隔离级别	                  脏读	   不可重复读	   幻读

读未提交（read-uncommitted）		 是					是					是
理解: 当前事务中能读取到 其他事务未提交的数据

不可重复读（read-committed）		  否					 是				 是
理解: 在当前事务中 读取多少次 都是最新的那个数据

可重复读（repeatable-read）(默认) 否						否					是
理解: 在当前事务中 读取多少次 都是第一次查询的数据结果

串行化(幻读)（serializable）		  否						否					否
理解: 原先的事务读取的数据 在另外一个事务操作数据后 ,本事务读取出来的数据 发生变化
```

### 数据库的索引类型

```
唯一索引：在创建唯一索引时要不能给具有相同的索引值。
主键索引：在我们给一个字段设置主键的时候，它就会自动创建主键索引，用来确保每一个值都是唯一的。
聚集索引：我们在表中添加数据的顺序，与我们创建的索引键值相同，而且一个表中只能有一个聚集索引。
普通索引：它的结构主要以B+树和哈希索引为主，主要是对数据表中的数据进行精确查找。
全文索引(FULLTEXT)：它的作用是搜索数据表中的字段是不是包含我们搜索的关键字，就像搜索引擎中的模糊查询。
```



# 真题

## mysql占用100%cpu，怎么排查

```
1. 执行linux命令:top 确认是mysql的问题

2.在db里面输入 show full processlist 查看正在执行的语句
   判断是不是并发查询大数据的问题 
2.1 如果不是的话 再看看是不是 死锁的问题 show engine innodb status \G; 

3.根据具体问题优化 死锁优化代码 查询优化语句索引之类的

```

## 索引的底层实现（B+树，为何不采用红黑树，B树）?

```
红黑树 -> 会根据增删改 调整树结构 浪费时间
B树   -> 查询不稳定 下转 会比B+树的层次多一点
B+树  ->  相对其他两种 树更宽 查询层次会短一点
```

## 索引失效条件是什么?

```
失效条件:
or 
like查询
is null查询
```

## 如何查看慢sql?

```
1. 利用druid的监控查看
2.开启慢sql日志
```

