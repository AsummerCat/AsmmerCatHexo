---
title: jvm的内存分配总结
date: 2018-12-07 14:31:29
tags: jvm
---

# JVM内存 结构划分

![内存结构](/img/2018-12-7/JVMmemory.png)  
![内存结构](/img/2018-12-7/JVMmemory2.png)



## 基本上分为这5块 

* 1.堆

* 2.虚拟机栈

* 3.方法区(永久代)  
>在JDK1.8中废弃了方法区 改用元空间(本地内存)

* 4.本地方法栈

* 5.程序计数器(寄存器)

<!--more-->

## 全局共享区域

* 堆内存    (基本上是new 的对象都存放在这里)

* 方法区  (存储已被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码)   
>在JDK1.8中废弃了方法区 改用元空间(本地内存)

> 这两块地方是整个程序共享的地方

## 线程独享区域

* 1.虚拟机栈  ( 启动一个线程 分配一个独立的栈 )
* 2.本地方法栈 (本地方法栈是为jvm使用到对的本地方法服务)
* 3.程序计数器  (当前线程所执行的字节码的行号指示器 运行的步骤)
> 这3个地方是线程独享的区域 

---
---
---


# 具体解释

## 堆
> java堆是jvm内存管理中最大的一块，线程共享。在jvm启动的时候创建。此区域唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。
> (简单来说就是 new 的对象都在这里) 

java堆细分为新生代和老年代
新生代(Young Gen)：新生代主要存放新创建的对象 垃圾回收会比较频繁  
年老代(Tenured Gen)：年老代主要存放JVM认为生命周期比较长的对象（经过几次的Young Gen的垃圾回收后仍然存在） 垃圾回收也相对没有那么频繁

### Eden 新生代 
新生代又分为Eden空间、From Survivor空间、To Survivor空间  

#### Eden空间   (垃圾回收 频繁)
   当对象在堆创建时，将进入年轻代的Eden Space。  

#### 新生代 GC算法 复制算法
具体回收过程是将Eden区域和From Survivor区域作为对象的存储空间，当要进行垃圾回收的时候先将这两个区域中不需要回收的对象复制保存在To Survivor区域中，然后再进行垃圾回收。另外有一点是当一个对象在Eden区域和From Survivor区域中存储的时候发现内存不足，这时会进行内存分配担保，就是将此对象直接存入在老年代中。

####  From Survivor空间     To Survivor空间  (幸存者区)
From Survivor空间、To Survivor空间   ---->这两个空间 是一样的  

  用于保存在eden space内存区域中经过垃圾回收后没有被回收的对象。  

执行垃圾回收的时候Eden区域不能被回收的对象被放入到空的survivor（也就是To Survivor，同时Eden区域的内存会在垃圾回收的过程中全部释放），另一个survivor（即From Survivor）里不能被回收的对象也会被放入这个survivor（即To Survivor），然后To Survivor 和 From Survivor的标记会互换，始终保证一个survivor是空的。

#### 结论

Eden Space和Survivor Space都属于新生代，新生代中执行的垃圾回收被称之为Minor GC（因为是对新生代进行垃圾回收，所以又被称为Young GC），每一次Young GC后留下来的对象age加1。

---
---
---

### 对象如何进入老年代

#### 大对象直接进入老年代

因为新生代是使用的复制算法，所以要尽量减少复制的内存，所以对象内存到一定的值后就会直接进入老年代。

####  新生代对象年龄到一定程度后进入老年代

每个对象会有一个Age的计数器，初始值为0，每经过一次GC并且存活，这个对象的Age就会加1，如果增加到一定程度（默认为15）。那么就会进入老年代中。

#### 动态对象年龄判定

如果在新生代存活区中相同年龄所有对象大小的总和大于存活区的一半，年龄大于或等于该年龄的对象就会直接进入老年代。 
比如现在存活区有三个对象，Age分别为2、2、3。那么Age为3的这个对象就会进入老年代。

---
---
---

### Old Gen 老年代

   用于存放新生代中经过多次垃圾回收仍然存活的对象，也有可能是新生代分配不了内存的大对象会直接进入老年代。(新生代 经过几次Minor GC 之后) ，这些对象的年代已经足够old了，就会放入到老年代。

#### 老年代 GC算法 标记-清除算法或者标记-整理算法

方法区永久代，回收方法同老年代。

#### FULL GC  (完整GC) 
当老年代被放满的之后，虚拟机会进行垃圾回收，称之为Major GC。由于Major GC除并发GC外均需对整个堆进行扫描和回收，因此又称为Full GC。

### VM参数   ----堆
heap区即堆内存，整个堆大小=年轻代大小 + 老年代大小。堆内存默认为物理内存的1/64(<1GB)；默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制，可以通过MinHeapFreeRatio参数进行调整；默认空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制，可以通过MaxHeapFreeRatio参数进行调整。

#### VM参数列表
-Xmx20m   ---->java应用最大可用内存为20M  
-Xms5m     ---->-Xms 最小分配内存5M  
-Xmn5M    ---->-Xmn 新生代配置内存  
-XX:NewRatio=4  ---> -XX:NewRatio 新生代和年老代的内存分配   新生代和年老代的内存分配比例为1:4  
-XX:SurvivorRatio=8  --> 新生代内部Survivor和Eden区域的比例         2Survivor：Eden=2:8  
-XX:MaxTenuringThreshold=0  --> 即新生代转入老生代的存活次数   默认15次
如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代对于年老代比较多的应用，可以提高效率。  

-XX:+PrintTenuringDistribution  -->    这个参数用于显示每次Minor GC时Survivor区中各个年龄段的对象的大小。  

---
---
---

##  方法区(永久代)    jdk1.8改为使用 元空间

Perm Gen全称是Permanent Generation space，是指内存的永久保存区域，因而称之为永久代。这个内存区域用于存放Class和Meta的信息，Class在被 Load的时候被放入这个区域。因为Perm里存储的东西永远不会被JVM垃圾回收的，所以如果你的应用程序LOAD很多CLASS的话，就很可能出现PermGen space错误。默认大小为物理内存的1/64。

方法区永久代，回收方法同老年代。

### 永久代的回收有两种

常量池中的常量，无用的类信息，常量的回收很简单，没有引用了就可以被回收。  
对于无用的类进行回收，必须保证3点：   
类的所有实例都已经被回收   
加载类的ClassLoader已经被回收   
类对象的Class对象没有被引用（即没有通过反射引用该类的地方）   
永久代的回收并不是必须的，可以通过参数来设置是否对类进行回收。HotSpot提供-Xnoclassgc进行控制   
使用-verbose，-XX:+TraceClassLoading、-XX:+TraceClassUnLoading可以查看类加载和卸载信息   
-verbose、-XX:+TraceClassLoading可以在Product版HotSpot中使用；   
-XX:+TraceClassUnLoading需要fastdebug版HotSpot支持   

### 方法区和持久代的关系
方法区物理上存在于堆里，而且是在堆的持久代里面；但在逻辑上，方法区和堆是独立的。  
一般说堆的持久代就是说方法区，因为一旦JVM把方法区（类信息，常量池，静态字段，方法）加载进内存以后，这些内存一般是不会被回收的了。

### 关于方法区和永久代

在HotSpot JVM中，这次讨论的永久代，就是上图的方法区（JVM规范中称为方法区）。《Java虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。在其他JVM上不存在永久代。

### JDK8永久代的废弃

JDK8 永久代变化如下:  

![元空间](/img/2018-12-7/metaSpace.jpg)  

* 1.新生代：Eden+From Survivor+To Survivor

* 2.老年代：OldGen

* 3.永久代（方法区的实现） : PermGen----->替换为Metaspace(本地内存中)

---

## jdk1.8 元空间

上面说过，HotSpot虚拟机在1.8之后已经取消了永久代，改为元空间，类的元信息被存储在元空间中。元空间没有使用堆内存，而是与堆不相连的本地内存区域。所以，理论上系统可以使用的内存有多大，元空间就有多大，所以不会出现永久代存在时的内存溢出问题。这项改造也是有必要的，永久代的调优是很困难的，虽然可以设置永久代的大小，但是很难确定一个合适的大小，因为其中的影响因素很多，比如类数量的多少、常量数量的多少等。永久代中的元数据的位置也会随着一次full GC发生移动，比较消耗虚拟机性能。同时，HotSpot虚拟机的每种类型的垃圾回收器都需要特殊处理永久代中的元数据。将元数据从永久代剥离出来，不仅实现了对元空间的无缝管理，还可以简化Full GC以及对以后的并发隔离类元数据等方面进行优化。

## 元空间是方法区的在HotSpot jvm 中的实现

方法区主要用于存储类的信息、常量池、方法数据、方法代码等。方法区逻辑上属于堆的一部分，但是为了与堆进行区分，通常又叫“非堆”。  

元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。，理论上取决于32位/64位系统可虚拟的内存大小。可见也不是无限制的，需要配置参数。

## 常用配置参数

*  使用Java -XX:+PrintFlagsInitial命令查看本机的初始化参数  

1.MetaspaceSize  

初始化的Metaspace大小，控制元空间发生GC的阈值。GC后，动态增加或降低MetaspaceSize。在默认情况下，这个值大小根据不同的平台在12M到20M浮动。使用Java -XX:+PrintFlagsInitial命令查看本机的初始化参数  

2.MaxMetaspaceSize  

限制Metaspace增长的上限，防止因为某些情况导致Metaspace无限的使用本地内存，影响到其他程序。在本机上该参数的默认值为4294967295B（大约4096MB）。  

3.MinMetaspaceFreeRatio  

当进行过Metaspace GC之后，会计算当前Metaspace的空闲空间比，如果空闲比小于这个参数（即实际非空闲占比过大，内存不够用），那么虚拟机将增长Metaspace的大小。默认值为40，也就是40%。设置该参数可以控制Metaspace的增长的速度，太小的值会导致Metaspace增长的缓慢，Metaspace的使用逐渐趋于饱和，可能会影响之后类的加载。而太大的值会导致Metaspace增长的过快，浪费内存。  

4.MaxMetasaceFreeRatio  

当进行过Metaspace GC之后， 会计算当前Metaspace的空闲空间比，如果空闲比大于这个参数，那么虚拟机会释放Metaspace的部分空间。默认值为70，也就是70%。  

5.MaxMetaspaceExpansion  

Metaspace增长时的最大幅度。在本机上该参数的默认值为5452592B（大约为5MB）。  

6.MinMetaspaceExpansion  

Metaspace增长时的最小幅度。在本机上该参数的默认值为340784B（大约330KB为）。  

---
---
---

## 虚拟机栈

### JVM 栈和栈帧

虚拟机只会对java栈执行两种操作：以栈帧为单位的压栈或者出栈。

```java
当一个新的线程创建时，JVM会为这个线程创建一个新的Stack。一个Java Stack在一个个独立的栈帧中存储了线程的状态。JVM只会在Java Stack中做两个操作：push 和 pop
```

```
一个线程当前正在执行的方法称之为线程的 当前方法，当前方法对应的栈帧称为 当前帧，当前方法所属的类称为 当前类，当前类的常量池称为 当前常量池。 在执行一个方法时，JVM会保存当前类和当前常量池的轨迹。当JVM执行 需要操作栈帧中数据的指令时，JVM会在当前栈帧进行处理。
```

```
当一个线程执行一个Java方法时，JVM将创建一个新的栈帧并且把它push到栈顶。此时新的栈帧就变成了当前栈帧，方法执行时，使用栈帧来存储参数、局部变量、中间指令以及其他数据。
```

每个线程有一个私有的栈，随着线程的创建而创建。栈里面存着的是一种叫“栈帧”的东西，每个方法会创建一个栈帧，栈帧中存放了局部变量表（基本数据类型和对象引用）、操作数栈、方法出口等信息。栈的大小可以固定也可以动态扩展。当栈调用深度大于JVM所允许的范围，会抛出StackOverflowError的错误，不过这个深度范围不是一个恒定的值  

> 用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 

![java栈帧](/img/2018-12-7/java栈帧.png)

由上图可以看出，Java栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法  

当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。

```
栈帧由三部分组成：局部变量表、操作数栈以及帧数据。
```

重要的是：栈帧的大小因局部变量表和操作数栈而异。书中对于size的描述如下：

```
当JVM执行一个方法时，它会检查class中的数据，以便确定一个方法执行时在局部变量表和操作数栈中所需存储的word size。然后，JVM会为当前方法创建一个size相对应的栈帧，然后把它push到栈顶。
```



## 在JVM栈这个数据区可能会发生抛出两种错误。 

1. StackOverflowError 出现在栈内存设置成固定值的时候，当程序执行需要的栈内存超过设定的固定值会抛出这个错误。 
2. OutOfMemoryError 出现在栈内存设置成动态增长的时候，当JVM尝试申请的内存大小超过了其可用内存时会抛出这个错误。



## 程序计时器(寄存器)

线程私有的，每个线程都会分配一个线程计时器，用来表示当前线程执行的字节码的行号指示器。在多线程中，一个线程执行的时候释放锁，另一个线程执行完，再回来执行前面线程的时候，就是通过程序计时器来获取继续执行的位置。  

倘若当前执行的是 JVM 的方法，则该寄存器中保存当前执行指令的地址；倘若执行的是native 方法，则PC寄存器中为空。

在通用的计算机体系中，程序计数器用来记录当前正在执行的指令，在JVM中也是如此。程序计数器是线程私有，所以当一个新的线程创建时，程序计数器也会创建。由于Java是支持多线程，Java中的程序计数器用来记录当前线程中正在执行的指令。如果当前正在执行的方法是本地方法，那么此刻程序计数器的值为undefined。注意这个区域是唯一一个不抛出OutOfMemoryError的运行时数据区。

---
---
---

## 本地方法栈

与虚拟机栈意义相似，区别在于虚拟机栈用于使Java方法，而本地方法栈则是针对于Native方法服务  

Java官方对于本地方法的定义为methods written in a language other than the Java programming language，就是使用非Java语言实现的方法  

这部分主要与虚拟机用到的 Native 方法相关，一般情况下， Java 应用程序员并不需要关心这部分的内容。

---
---
---